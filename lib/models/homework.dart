import 'package:cloud_firestore/cloud_firestore.dart';

/// Grade levels for homework
enum GradeBand { 
  kres('Kreş'),
  anaokulu('Anaokulu'),
  ilkokul('İlkokul');
  
  final String label;
  const GradeBand(this.label);
}

/// Time window for homework
enum TimeWindow { 
  gunluk('Günlük'),
  haftalik('Haftalık'),
  telafi('Telafi');
  
  final String label;
  const TimeWindow(this.label);
}

/// Difficulty level
enum Difficulty { 
  kolay('Kolay'),
  orta('Orta'),
  zor('Zor');
  
  final String label;
  const Difficulty(this.label);
}

/// Homework format types
enum HomeworkFormat { 
  mcq('Çoktan Seçmeli'),
  trueFalse('Doğru/Yanlış'),
  matching('Eşleştirme'),
  fillBlank('Boşluk Doldurma'),
  shortText('Kısa Yanıt'),
  longText('Uzun Yanıt'),
  drawing('Çizim'),
  handsOn('Uygulamalı'),
  photoWorksheet('Foto Çalışma Sayfası');
  
  final String label;
  const HomeworkFormat(this.label);
}

/// Submission type
enum SubmissionType { 
  interactive('İnteraktif'),
  text('Metin'),
  photo('Fotoğraf');
  
  final String label;
  const SubmissionType(this.label);
}

/// Homework status
enum HomeworkStatus { 
  draft('Taslak'),
  published('Yayınlandı'),
  closed('Kapatıldı');
  
  final String label;
  const HomeworkStatus(this.label);
}

/// Grading criterion
class Criterion {
  final String name;
  final int points;

  const Criterion({
    required this.name,
    required this.points,
  });

  factory Criterion.fromJson(Map<String, dynamic> json) {
    return Criterion(
      name: json['name'] as String,
      points: json['points'] as int,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'points': points,
    };
  }
}

/// Grading rubric
class GradingRubric {
  final int maxScore;
  final List<Criterion> criteria;

  const GradingRubric({
    required this.maxScore,
    required this.criteria,
  });

  factory GradingRubric.fromJson(Map<String, dynamic> json) {
    return GradingRubric(
      maxScore: json['maxScore'] as int,
      criteria: (json['criteria'] as List)
          .map((e) => Criterion.fromJson(e as Map<String, dynamic>))
          .toList(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'maxScore': maxScore,
      'criteria': criteria.map((c) => c.toJson()).toList(),
    };
  }
}

/// Teacher answer key (visible only to teacher)
class TeacherAnswerKey {
  final String notes;
  final List<String> expectedPoints;
  final List<String> sampleAnswers;
  final List<String>? mcqCorrect; // for MCQ format

  const TeacherAnswerKey({
    required this.notes,
    required this.expectedPoints,
    required this.sampleAnswers,
    this.mcqCorrect,
  });

  factory TeacherAnswerKey.fromJson(Map<String, dynamic> json) {
    return TeacherAnswerKey(
      notes: json['notes'] as String,
      expectedPoints: (json['expectedPoints'] as List).cast<String>(),
      sampleAnswers: (json['sampleAnswers'] as List).cast<String>(),
      mcqCorrect: (json['mcqCorrect'] as List?)?.cast<String>(),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'notes': notes,
      'expectedPoints': expectedPoints,
      'sampleAnswers': sampleAnswers,
      'mcqCorrect': mcqCorrect,
    };
  }
}

/// Adaptations for different skill levels
class Adaptations {
  final String easy;
  final String hard;

  const Adaptations({
    required this.easy,
    required this.hard,
  });

  factory Adaptations.fromJson(Map<String, dynamic> json) {
    return Adaptations(
      easy: json['easy'] as String,
      hard: json['hard'] as String,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'easy': easy,
      'hard': hard,
    };
  }
}

/// Single homework option generated by AI
class HomeworkOption {
  final String optionId;
  final String title;
  final String goal;
  final HomeworkFormat format;
  final int estimatedMinutes;
  final List<String> materials;
  final List<String> studentInstructions;
  final List<String> parentGuidance;
  final SubmissionType submissionType;
  final GradingRubric gradingRubric;
  final TeacherAnswerKey teacherAnswerKey;
  final Adaptations adaptations;

  const HomeworkOption({
    required this.optionId,
    required this.title,
    required this.goal,
    required this.format,
    required this.estimatedMinutes,
    required this.materials,
    required this.studentInstructions,
    required this.parentGuidance,
    required this.submissionType,
    required this.gradingRubric,
    required this.teacherAnswerKey,
    required this.adaptations,
  });

  factory HomeworkOption.fromJson(Map<String, dynamic> json) {
    return HomeworkOption(
      optionId: json['optionId'] as String,
      title: json['title'] as String,
      goal: json['goal'] as String,
      format: HomeworkFormat.values.firstWhere(
        (e) => e.name == json['format'],
      ),
      estimatedMinutes: json['estimatedMinutes'] as int,
      materials: (json['materials'] as List).cast<String>(),
      studentInstructions: (json['studentInstructions'] as List).cast<String>(),
      parentGuidance: (json['parentGuidance'] as List).cast<String>(),
      submissionType: SubmissionType.values.firstWhere(
        (e) => e.name == json['submissionType'],
      ),
      gradingRubric: GradingRubric.fromJson(json['gradingRubric'] as Map<String, dynamic>),
      teacherAnswerKey: TeacherAnswerKey.fromJson(json['teacherAnswerKey'] as Map<String, dynamic>),
      adaptations: Adaptations.fromJson(json['adaptations'] as Map<String, dynamic>),
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'optionId': optionId,
      'title': title,
      'goal': goal,
      'format': format.name,
      'estimatedMinutes': estimatedMinutes,
      'materials': materials,
      'studentInstructions': studentInstructions,
      'parentGuidance': parentGuidance,
      'submissionType': submissionType.name,
      'gradingRubric': gradingRubric.toJson(),
      'teacherAnswerKey': teacherAnswerKey.toJson(),
      'adaptations': adaptations.toJson(),
    };
  }
}

/// Published homework assignment
class Homework {
  final String id;
  final String classId;
  final String teacherId;
  final String selectedOptionId;
  final HomeworkOption option;
  final List<String> targetStudentIds; // empty = all class
  final HomeworkStatus status;
  final DateTime createdAt;
  final DateTime? publishedAt;
  final DateTime? dueDate;
  final DateTime? closedAt;

  const Homework({
    required this.id,
    required this.classId,
    required this.teacherId,
    required this.selectedOptionId,
    required this.option,
    required this.targetStudentIds,
    required this.status,
    required this.createdAt,
    this.publishedAt,
    this.dueDate,
    this.closedAt,
  });

  factory Homework.fromJson(Map<String, dynamic> json) {
    return Homework(
      id: json['id'] as String,
      classId: json['classId'] as String,
      teacherId: json['teacherId'] as String,
      selectedOptionId: json['selectedOptionId'] as String,
      option: HomeworkOption.fromJson(json['option'] as Map<String, dynamic>),
      targetStudentIds: (json['targetStudentIds'] as List).cast<String>(),
      status: HomeworkStatus.values.firstWhere(
        (e) => e.name == json['status'],
      ),
      createdAt: DateTime.fromMillisecondsSinceEpoch(json['createdAt'] as int),
      publishedAt: json['publishedAt'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['publishedAt'] as int)
          : null,
      dueDate: json['dueDate'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['dueDate'] as int)
          : null,
      closedAt: json['closedAt'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['closedAt'] as int)
          : null,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'classId': classId,
      'teacherId': teacherId,
      'selectedOptionId': selectedOptionId,
      'option': option.toJson(),
      'targetStudentIds': targetStudentIds,
      'status': status.name,
      'createdAt': createdAt.millisecondsSinceEpoch,
      'publishedAt': publishedAt?.millisecondsSinceEpoch,
      'dueDate': dueDate?.millisecondsSinceEpoch,
      'closedAt': closedAt?.millisecondsSinceEpoch,
    };
  }

  // Firestore serialization
  factory Homework.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Homework(
      id: doc.id,
      classId: data['classId'] as String,
      teacherId: data['teacherId'] as String,
      selectedOptionId: data['selectedOptionId'] as String,
      option: HomeworkOption.fromJson(data['option'] as Map<String, dynamic>),
      targetStudentIds: (data['targetStudentIds'] as List).cast<String>(),
      status: HomeworkStatus.values.firstWhere(
        (e) => e.name == data['status'],
      ),
      createdAt: (data['createdAt'] as Timestamp).toDate(),
      publishedAt: data['publishedAt'] != null
          ? (data['publishedAt'] as Timestamp).toDate()
          : null,
      dueDate: data['dueDate'] != null
          ? (data['dueDate'] as Timestamp).toDate()
          : null,
      closedAt: data['closedAt'] != null
          ? (data['closedAt'] as Timestamp).toDate()
          : null,
    );
  }

  Map<String, dynamic> toFirestore() {
    return {
      'classId': classId,
      'teacherId': teacherId,
      'selectedOptionId': selectedOptionId,
      'option': option.toJson(),
      'targetStudentIds': targetStudentIds,
      'status': status.name,
      'createdAt': Timestamp.fromDate(createdAt),
      'publishedAt': publishedAt != null ? Timestamp.fromDate(publishedAt!) : null,
      'dueDate': dueDate != null ? Timestamp.fromDate(dueDate!) : null,
      'closedAt': closedAt != null ? Timestamp.fromDate(closedAt!) : null,
    };
  }

  Homework copyWith({
    HomeworkStatus? status,
    DateTime? publishedAt,
    DateTime? dueDate,
    DateTime? closedAt,
    HomeworkOption? option,
  }) {
    return Homework(
      id: id,
      classId: classId,
      teacherId: teacherId,
      selectedOptionId: selectedOptionId,
      option: option ?? this.option,
      targetStudentIds: targetStudentIds,
      status: status ?? this.status,
      createdAt: createdAt,
      publishedAt: publishedAt ?? this.publishedAt,
      dueDate: dueDate ?? this.dueDate,
      closedAt: closedAt ?? this.closedAt,
    );
  }
}
